// ON N'UTILISE PLUS CETTE FONCTION POUR L'INSTANT !
//Chemin* DFS(Edge *edgeCurrent,Problem *theProblem)
//{
///*
//Specification:
//Returns a Chemin structure that goes from the Node "edgeCurrent->b" to "edgeCurrent->a".
//edgeCurrent is an edge that does not belong to theTree.
//*/
//	
//	/// DFS ///
//	int i; 
//	int found=0;
//	int *generators = new int[theProblem->nNode];
//	//int *generators = malloc(sizeof(int)*theProblem->nNode);
//	int numberEdges = 0;
//	Node *nodeA= edgeCurrent->a;
//	Node *nodeB= edgeCurrent->b;
//	/// 1) DFS from nodeA tot nodeB ////
//	queue<int> myqueue;
//	myqueue.push(nodeA->indice);
//	
//	while(!myqueue.empty())
//	{
//        if(myqueue.front() == nodeB->indice)
//        {
//        	found =1;// check pour dire qu'on a trouvé le node destination 
//        	break;
//        } 
//	else
//	{
//		int currentNode=myqueue.front();// on va spliter ce node
//        	myqueue.pop();
//        	for (i = 0; i < theProblem->nodes[currentNode].degree ; i++)
//            	{	
//			myqueue.push(theProblem->nodes[currentNode].voisins[i]->indice);
//			generators[theProblem->nodes[currentNode].voisins[i]->indice]=currentNode;// TODO tc                 	
//            	}
//            }
//    	}
//    
//	// sanity check
//	if (found ==1)	
//	{
//		 cout << "on a found le chemin \n ";
//	}
//	else{
//		cout << "ERROR: chemin not found in DFS \n";
//	}
//	
//	/// 2) Recover path ////
//	
//	// la structure à remplir, (puis changer ordre pour les edges ?)
//	//Chemin *chemin=malloc(sizeof(Chemin));
//	Chemin *chemin=new Chemin[1];
//	chemin->size=0;
//	chemin->theChemin=NULL;
//	int *reverse=new int[theProblem->nEdge];
//	//malloc(theProblem->nEdge*sizeof(Edge));// on le rempli trop grand mais on va pas jusqu'au bout
//	
//	int k=nodeB->indice;						   	
//	while( generators[k] != nodeA->indice)
//	{// remplir reverse en parcourant le mapping
//		
//		// trouver l'indice de l'edge qui relie les nodes d'indices k et generators[k]:
//		for(i=0; i< theProblem->nodes[k].degree; i++ )
//		{
//			if( (theProblem->nodes[k].incidentes[i]->a->indice == k &&
//			     theProblem->nodes[k].incidentes[i]->b->indice == generators[k] ) || 
//			     (theProblem->nodes[k].incidentes[i]->a->indice == generators[k] &&
//			     theProblem->nodes[k].incidentes[i]->b->indice == k ) )
//			{
//				reverse[chemin->size]=theProblem->nodes[k].incidentes[i]->indice;
//				break; 	
//			}
//		}
//		chemin->size= chemin->size+1;	
//		k=generators[k];
//	}
//	chemin->theChemin=new Edge*[chemin->size];
//	//malloc(theChemin->size*sizeof(Edge));
//	for(i=0; i<chemin->size; i++)
//	{
//		chemin->theChemin[i]=&(theProblem->edges[reverse[i]]);// theChemin c'est des pointeurs et reverse c'est des indices
//	}
	
/* ON A PEUT ETRE PAS BESOIN DE RETOURNER LE CYCLE, DEPEND DES SIGNES de flots ETC, TODO à vérifier */	
//	chemin->size=numberEdges;
//	chemin->theChemin=malloc(numberEdges*sizeof(Edge));
//	for(i=0; i<numberEdges; i++)
//	{
//		chemin->theChemin[i]=reverse[numberEdges-1-i];
//	}
	
//	return chemin;
//}



int sizeEdgeA=0;
	int sizeNodeA=0;
	Edge **edgeGuessA=malloc((theProblem->nEdge*sizeof(Edge)));
	Node **nodeGuessA=malloc((theProblem->nNode*sizeof(Node)));
	nodeGuessA[0]=theProblem->theTree->node;
	sizeNodeA++;
	int sizeEdgeB=0;
	int sizeNodeB=0;
	Edge **edgeGuessB=malloc((theProblem->nEdge*sizeof(Edge)));
	Node **nodeGuessB=malloc((theProblem->nNode*sizeof(Node)));
	nodeGuessB[0]=theProblem->theTree->node;
	sizeNodeB++;
	
/////////////////////////////////////////////////////////////////////////


int N=fmin(sizeNodeB,sizeNodeA);
	
	for(i=1; i<=N ; i++)
	{
		if(nodeGuessA[ sizeNodeA-i ]->indice == nodeGuessB[ sizeNodeB-i]->indice)
		{
			// TODO mettre ensmeble les deux listes d'edges (utiliser i pour savoir comment couper je crois)
			// et puis retourner le chemin total (attention à bien traiter le cas limite où le node[0] est sur le chemin)
			// voir autre cas limite: le node[0] est une des extrémités de edgeCurrent (très facile)
			//break; 
		}
	
	}
	
	
	/////////////////////////////////////////////////////
	// approches du code avec les incidentes             	TO DELETE	
//	      	       	if ( theProblem->nodes[currentNode].incidentes[i]->a->indice == currentNode)
//	      	       	{// on est dans le cas où le currentNode est "à la base (coté a) de l'edge qu'on emprunte" 
//	      	       		myqueue.push( theProblem->nodes[currentNode].incidentes[i]->b->indice  );// TODO check
//                		generators[theProblem->nodes[currentNode].incidentes[i]->b->indice] = currentNode;
//	      	       	}
//	      	       	else
//	      	       	{// on est dans le cas où le currentNode est "à l'autre bout (coté b) de l'edge qu'on emprunte"
//	      	       		myqueue.push( theProblem->nodes[currentNode].incidentes[i]->a->indice  );// TODO check
//	                	generators[theProblem->nodes[currentNode].incidentes[i]->a->indice] = currentNode;
//	      	       	}



///////////////////////////////////////////////////////////////////:

//    FILE* file = fopen(FileName,"r");

//    trash = fscanf(file, "Number of nodes %d \n", &theProblem->nNode);
//    int nNode=theProblem->nNode;
//    printf("nNode: %d \n", nNode);

//    double** theArray;
//    theArray = (double**) malloc(nNode*sizeof(double*));
//    for (i = 0; i < nNode; i++)
//       theArray[i] = (double*) malloc(nNode*sizeof(double));

//    theProblem->Weights=theArray;
//    printf("on est là\n");

  /*  for(i = 0; i < nNode; i++)
  {
      for(j = 0; j < nNode; j++)
      {
  //Use lf format specifier, %c is for character
       if (!fscanf(file, "%lf", &theProblem->Weights[i][j]))
       {
       	printf("break\n");
        break;
       }
      // mat[i][j] -= '0';
       printf("%lf \n",theProblem->Weights[i][j]); //Use lf format specifier, \n is for new line
      }
  }*/

    /* while(getline(&line, &count, file)!=-1) {
        for (; count > 0; count--, j++)
            sscanf(line, "%lf", &theProblem->Weights[i][j]);
        i++;
    }*/
    
   /* for (i = 0; i < nNode; i++)
    {
    	for(j=0; j < nNode; j++)
    	{
    		fscanf(" .. ", theProblem->Weights[i][j]);
    	}
    	//ici il faut aller à la ligne
    }*/

//int nNode=4;

////////////////////////////////////////////////////////////////:

/*edgeSort(theProblem);
	int i;
	for(i=0; i<theProblem->nEdge;i++)
	{// on remet les indices comme il faut après avoir trié
		theProblem->edges[i].indice=i;
	}
	//int *indexEdge=malloc(sizeof(int)*(theProblem->nNode-1));
	*/
